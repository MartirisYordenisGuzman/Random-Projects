{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nvar noop = function noop() {};\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n    _classCallCheck(this, RealtimeClient);\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    var eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.disconnect();\n                this.connect();\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      if (this.conn) {\n        return;\n      }\n      this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n      if (this.conn) {\n        this.conn.binaryType = 'arraybuffer';\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n        this.conn.onmessage = function (event) {\n          return _this2._onConnMessage(event);\n        };\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n        // remove open handles\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.reset();\n      }\n    }\n  }, {\n    key: \"getChannels\",\n    value: function getChannels() {\n      return this.channels;\n    }\n  }, {\n    key: \"removeChannel\",\n    value: function removeChannel(channel) {\n      var _this3 = this;\n      return channel.unsubscribe().then(function (status) {\n        if (_this3.channels.length === 0) {\n          _this3.disconnect();\n        }\n        return status;\n      });\n    }\n  }, {\n    key: \"removeAllChannels\",\n    value: function removeAllChannels() {\n      var _this4 = this;\n      return Promise.all(this.channels.map(function (channel) {\n        return channel.unsubscribe();\n      })).then(function (values) {\n        _this4.disconnect();\n        return values;\n      });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        config: {}\n      };\n      if (!this.isConnected()) {\n        this.connect();\n      }\n      var chan = new RealtimeChannel(\"realtime:\".concat(topic), params, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this5 = this;\n      var topic = data.topic,\n        event = data.event,\n        payload = data.payload,\n        ref = data.ref;\n      var callback = function callback() {\n        _this5.encode(data, function (result) {\n          var _a;\n          (_a = _this5.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n      if (this.isConnected()) {\n        if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n          var isThrottled = this._throttle(callback)();\n          if (isThrottled) {\n            return 'rate limited';\n          }\n        } else {\n          callback();\n        }\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          access_token: token\n        });\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n  }, {\n    key: \"_makeRef\",\n    value: function _makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n      return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_leaveOpenTopic\",\n    value: function _leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c._isJoined() || c._isJoining());\n      });\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_remove\",\n    value: function _remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c._joinRef() !== channel._joinRef();\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_endPointURL\",\n    value: function _endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnMessage\",\n    value: function _onConnMessage(rawMessage) {\n      var _this6 = this;\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref;\n        if (ref && ref === _this6.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this6.pendingHeartbeatRef = null;\n        }\n        _this6.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n        _this6.channels.filter(function (channel) {\n          return channel._isMember(topic);\n        }).forEach(function (channel) {\n          return channel._trigger(event, payload, ref);\n        });\n        _this6.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this7 = this;\n      this.log('transport', \"connected to \".concat(this._endPointURL()));\n      this._flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this7._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n      this._triggerChanError();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n      this._triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel._trigger(CHANNEL_EVENTS.error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n    /** @internal */\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      this.pendingHeartbeatRef = this._makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n    /** @internal */\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(callback) {\n      var _this8 = this;\n      var eventsPerSecondLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n      return function () {\n        if (_this8.inThrottle) return true;\n        callback();\n        _this8.inThrottle = true;\n        setTimeout(function () {\n          _this8.inThrottle = false;\n        }, eventsPerSecondLimit);\n        return false;\n      };\n    }\n  }]);\n  return RealtimeClient;\n}();\nexport { RealtimeClient as default };","map":{"version":3,"mappings":"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","names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","endPoint","options","undefined","open","close","error","message","websocket","params","headers","timeout","logger","transport","heartbeatIntervalMs","eventsPerSecond","eventsPerSecondLimitMs","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","serializer","bind","reconnectTimer","__awaiter","disconnect","connect","conn","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","heartbeatTimer","clearInterval","reset","channels","channel","unsubscribe","then","status","length","Promise","all","map","values","kind","msg","data","readyState","connecting","Connecting","Open","closing","Closing","Closed","connectionState","topic","config","isConnected","chan","push","ref","result","send","log","includes","isThrottled","_throttle","sendBuffer","token","accessToken","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","newRef","toString","dupChannel","find","c","_isJoining","filter","_joinRef","_appendParams","Object","assign","vsn","rawMessage","pendingHeartbeatRef","type","_isMember","_trigger","stateChangeCallbacks","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","_makeRef","setAuth","eventsPerSecondLimit","inThrottle","setTimeout"],"sources":["C:\\Users\\zoila\\OneDrive\\Escritorio\\Today-i-learned\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel, { RealtimeChannelOptions } from './RealtimeChannel'\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    return channel.unsubscribe().then((status) => {\n      if (this.channels.length === 0) {\n        this.disconnect()\n      }\n      return status\n    })\n  }\n\n  removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    return Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    ).then((values) => {\n      this.disconnect()\n      return values\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    if (!this.isConnected()) {\n      this.connect()\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimit: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n      callback()\n      this.inThrottle = true\n      setTimeout(() => {\n        this.inThrottle = false\n      }, eventsPerSecondLimit)\n      return false\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}