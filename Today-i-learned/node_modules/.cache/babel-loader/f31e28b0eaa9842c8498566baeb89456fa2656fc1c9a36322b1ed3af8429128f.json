{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/zoila/OneDrive/Escritorio/Today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n      return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$this$_getSessi, data, error, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.initializePromise) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", this.initializePromise);\n              case 2:\n                _context.prev = 2;\n                if (!(this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n                  _context.next = 19;\n                  break;\n                }\n                _context.next = 6;\n                return this._getSessionFromUrl();\n              case 6:\n                _yield$this$_getSessi = _context.sent;\n                data = _yield$this$_getSessi.data;\n                error = _yield$this$_getSessi.error;\n                if (!error) {\n                  _context.next = 13;\n                  break;\n                }\n                _context.next = 12;\n                return this._removeSession();\n              case 12:\n                return _context.abrupt(\"return\", {\n                  error: error\n                });\n              case 13:\n                session = data.session, redirectType = data.redirectType;\n                _context.next = 16;\n                return this._saveSession(session);\n              case 16:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n                if (redirectType === 'recovery') {\n                  this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                }\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n              case 19:\n                _context.next = 21;\n                return this._recoverAndRefresh();\n              case 21:\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](2);\n                if (!isAuthError(_context.t0)) {\n                  _context.next = 28;\n                  break;\n                }\n                return _context.abrupt(\"return\", {\n                  error: _context.t0\n                });\n              case 28:\n                return _context.abrupt(\"return\", {\n                  error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n                });\n              case 29:\n                _context.prev = 29;\n                this._handleVisibilityChange();\n                return _context.finish(29);\n              case 32:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 24, 29, 32]]);\n      }));\n    }\n    /**\n     * Creates a new user.\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, phone, _password, _options, _res, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._removeSession();\n              case 3:\n                if (!('email' in credentials)) {\n                  _context2.next = 10;\n                  break;\n                }\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context2.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n              case 7:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context2.next = 17;\n                  break;\n                }\n                phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n                _context2.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password,\n                    data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                      captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n              case 14:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n              case 18:\n                _res = res, data = _res.data, error = _res.error;\n                if (!(error || !data)) {\n                  _context2.next = 21;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n              case 21:\n                session = data.session;\n                user = data.user;\n                if (!data.session) {\n                  _context2.next = 27;\n                  break;\n                }\n                _context2.next = 26;\n                return this._saveSession(data.session);\n              case 26:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n              case 27:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](0);\n                if (!isAuthError(_context2.t0)) {\n                  _context2.next = 34;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context2.t0\n                });\n              case 34:\n                throw _context2.t0;\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 30]]);\n      }));\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     */\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this._removeSession();\n              case 3:\n                if (!('email' in credentials)) {\n                  _context3.next = 10;\n                  break;\n                }\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context3.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n              case 7:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context3.next = 17;\n                  break;\n                }\n                phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n                _context3.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password2,\n                    data: (_b = _options2 === null || _options2 === void 0 ? void 0 : _options2.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                      captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n              case 14:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n              case 18:\n                _res2 = res, data = _res2.data, error = _res2.error;\n                if (!(error || !data)) {\n                  _context3.next = 21;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n              case 21:\n                if (!data.session) {\n                  _context3.next = 25;\n                  break;\n                }\n                _context3.next = 24;\n                return this._saveSession(data.session);\n              case 24:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n              case 25:\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n              case 28:\n                _context3.prev = 28;\n                _context3.t0 = _context3[\"catch\"](0);\n                if (!isAuthError(_context3.t0)) {\n                  _context3.next = 32;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context3.t0\n                });\n              case 32:\n                throw _context3.t0;\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._removeSession();\n              case 2:\n                return _context4.abrupt(\"return\", this._handleProviderSignIn(credentials.provider, {\n                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n                }));\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     */\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var email, options, _yield$_request, error, phone, _options3, _yield$_request2, _error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return this._removeSession();\n              case 3:\n                if (!('email' in credentials)) {\n                  _context5.next = 10;\n                  break;\n                }\n                email = credentials.email, options = credentials.options;\n                _context5.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n              case 7:\n                _yield$_request = _context5.sent;\n                error = _yield$_request.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context5.next = 17;\n                  break;\n                }\n                phone = credentials.phone, _options3 = credentials.options;\n                _context5.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                    create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                    gotrue_meta_security: {\n                      captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                    }\n                  }\n                });\n              case 14:\n                _yield$_request2 = _context5.sent;\n                _error = _yield$_request2.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _error\n                });\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n              case 20:\n                _context5.prev = 20;\n                _context5.t0 = _context5[\"catch\"](0);\n                if (!isAuthError(_context5.t0)) {\n                  _context5.next = 24;\n                  break;\n                }\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context5.t0\n                });\n              case 24:\n                throw _context5.t0;\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 20]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _yield$_request3, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return this._removeSession();\n              case 3:\n                _context6.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                  headers: this.headers,\n                  body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                      captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                    }\n                  }),\n                  redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                  xform: _sessionResponse\n                });\n              case 5:\n                _yield$_request3 = _context6.sent;\n                data = _yield$_request3.data;\n                error = _yield$_request3.error;\n                if (!error) {\n                  _context6.next = 10;\n                  break;\n                }\n                throw error;\n              case 10:\n                if (data) {\n                  _context6.next = 12;\n                  break;\n                }\n                throw 'An error occurred on token verification.';\n              case 12:\n                session = data.session;\n                user = data.user;\n                if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                  _context6.next = 18;\n                  break;\n                }\n                _context6.next = 17;\n                return this._saveSession(session);\n              case 17:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n              case 18:\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n              case 21:\n                _context6.prev = 21;\n                _context6.t0 = _context6[\"catch\"](0);\n                if (!isAuthError(_context6.t0)) {\n                  _context6.next = 25;\n                  break;\n                }\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context6.t0\n                });\n              case 25:\n                throw _context6.t0;\n              case 26:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     *\n     * This API is experimental and availability is conditional on correct\n     * settings on the Auth service.\n     *\n     * @experimental\n     */\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return this._removeSession();\n              case 3:\n                _context7.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                  body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                    provider_id: params.providerId\n                  } : null), 'domain' in params ? {\n                    domain: params.domain\n                  } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                  }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                      captcha_token: params.options.captchaToken\n                    }\n                  } : null), {\n                    skip_http_redirect: true\n                  }),\n                  headers: this.headers,\n                  xform: _ssoResponse\n                });\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](0);\n                if (!isAuthError(_context7.t0)) {\n                  _context7.next = 12;\n                  break;\n                }\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n              case 12:\n                throw _context7.t0;\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.initializePromise;\n              case 2:\n                currentSession = null;\n                if (!this.persistSession) {\n                  _context8.next = 16;\n                  break;\n                }\n                _context8.next = 6;\n                return getItemAsync(this.storage, this.storageKey);\n              case 6:\n                maybeSession = _context8.sent;\n                if (!(maybeSession !== null)) {\n                  _context8.next = 14;\n                  break;\n                }\n                if (!this._isValidSession(maybeSession)) {\n                  _context8.next = 12;\n                  break;\n                }\n                currentSession = maybeSession;\n                _context8.next = 14;\n                break;\n              case 12:\n                _context8.next = 14;\n                return this._removeSession();\n              case 14:\n                _context8.next = 17;\n                break;\n              case 16:\n                currentSession = this.inMemorySession;\n              case 17:\n                if (currentSession) {\n                  _context8.next = 19;\n                  break;\n                }\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: null\n                });\n              case 19:\n                hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n                if (hasExpired) {\n                  _context8.next = 22;\n                  break;\n                }\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: currentSession\n                  },\n                  error: null\n                });\n              case 22:\n                _context8.next = 24;\n                return this._callRefreshToken(currentSession.refresh_token);\n              case 24:\n                _yield$this$_callRefr = _context8.sent;\n                session = _yield$this$_callRefr.session;\n                error = _yield$this$_callRefr.error;\n                if (!error) {\n                  _context8.next = 29;\n                  break;\n                }\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: error\n                });\n              case 29:\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    session: session\n                  },\n                  error: null\n                });\n              case 30:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _yield$this$getSessio, data, error;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                if (jwt) {\n                  _context9.next = 10;\n                  break;\n                }\n                _context9.next = 4;\n                return this.getSession();\n              case 4:\n                _yield$this$getSessio = _context9.sent;\n                data = _yield$this$getSessio.data;\n                error = _yield$this$getSessio.error;\n                if (!error) {\n                  _context9.next = 9;\n                  break;\n                }\n                throw error;\n              case 9:\n                // Default to Authorization header if there is no existing session\n                jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n              case 10:\n                _context9.next = 12;\n                return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  jwt: jwt,\n                  xform: _userResponse\n                });\n              case 12:\n                return _context9.abrupt(\"return\", _context9.sent);\n              case 15:\n                _context9.prev = 15;\n                _context9.t0 = _context9[\"catch\"](0);\n                if (!isAuthError(_context9.t0)) {\n                  _context9.next = 19;\n                  break;\n                }\n                return _context9.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context9.t0\n                });\n              case 19:\n                throw _context9.t0;\n              case 20:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request4, data, userError;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.getSession();\n              case 3:\n                _yield$this$getSessio2 = _context10.sent;\n                sessionData = _yield$this$getSessio2.data;\n                sessionError = _yield$this$getSessio2.error;\n                if (!sessionError) {\n                  _context10.next = 8;\n                  break;\n                }\n                throw sessionError;\n              case 8:\n                if (sessionData.session) {\n                  _context10.next = 10;\n                  break;\n                }\n                throw new AuthSessionMissingError();\n              case 10:\n                session = sessionData.session;\n                _context10.next = 13;\n                return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  body: attributes,\n                  jwt: session.access_token,\n                  xform: _userResponse\n                });\n              case 13:\n                _yield$_request4 = _context10.sent;\n                data = _yield$_request4.data;\n                userError = _yield$_request4.error;\n                if (!userError) {\n                  _context10.next = 18;\n                  break;\n                }\n                throw userError;\n              case 18:\n                session.user = data.user;\n                _context10.next = 21;\n                return this._saveSession(session);\n              case 21:\n                this._notifyAllSubscribers('USER_UPDATED', session);\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    user: session.user\n                  },\n                  error: null\n                });\n              case 25:\n                _context10.prev = 25;\n                _context10.t0 = _context10[\"catch\"](0);\n                if (!isAuthError(_context10.t0)) {\n                  _context10.next = 29;\n                  break;\n                }\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context10.t0\n                });\n              case 29:\n                throw _context10.t0;\n              case 30:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                  _context11.next = 3;\n                  break;\n                }\n                throw new AuthSessionMissingError();\n              case 3:\n                timeNow = Date.now() / 1000;\n                expiresAt = timeNow;\n                hasExpired = true;\n                session = null;\n                payload = decodeJWTPayload(currentSession.access_token);\n                if (payload.exp) {\n                  expiresAt = payload.exp;\n                  hasExpired = expiresAt <= timeNow;\n                }\n                if (!hasExpired) {\n                  _context11.next = 22;\n                  break;\n                }\n                _context11.next = 12;\n                return this._callRefreshToken(currentSession.refresh_token);\n              case 12:\n                _yield$this$_callRefr2 = _context11.sent;\n                refreshedSession = _yield$this$_callRefr2.session;\n                error = _yield$this$_callRefr2.error;\n                if (!error) {\n                  _context11.next = 17;\n                  break;\n                }\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n              case 17:\n                if (refreshedSession) {\n                  _context11.next = 19;\n                  break;\n                }\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n              case 19:\n                session = refreshedSession;\n                _context11.next = 30;\n                break;\n              case 22:\n                _context11.next = 24;\n                return this.getUser(currentSession.access_token);\n              case 24:\n                _yield$this$getUser = _context11.sent;\n                data = _yield$this$getUser.data;\n                _error2 = _yield$this$getUser.error;\n                if (!_error2) {\n                  _context11.next = 29;\n                  break;\n                }\n                throw _error2;\n              case 29:\n                session = {\n                  access_token: currentSession.access_token,\n                  refresh_token: currentSession.refresh_token,\n                  user: data.user,\n                  token_type: 'bearer',\n                  expires_in: expiresAt - timeNow,\n                  expires_at: expiresAt\n                };\n              case 30:\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n              case 33:\n                _context11.prev = 33;\n                _context11.t0 = _context11[\"catch\"](0);\n                if (!isAuthError(_context11.t0)) {\n                  _context11.next = 37;\n                  break;\n                }\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context11.t0\n                });\n              case 37:\n                throw _context11.t0;\n              case 38:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 33]]);\n      }));\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                if (currentSession) {\n                  _context12.next = 10;\n                  break;\n                }\n                _context12.next = 4;\n                return this.getSession();\n              case 4:\n                _yield$this$getSessio3 = _context12.sent;\n                data = _yield$this$getSessio3.data;\n                _error3 = _yield$this$getSessio3.error;\n                if (!_error3) {\n                  _context12.next = 9;\n                  break;\n                }\n                throw _error3;\n              case 9:\n                currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n              case 10:\n                if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                  _context12.next = 12;\n                  break;\n                }\n                throw new AuthSessionMissingError();\n              case 12:\n                _context12.next = 14;\n                return this._callRefreshToken(currentSession.refresh_token);\n              case 14:\n                _yield$this$_callRefr3 = _context12.sent;\n                session = _yield$this$_callRefr3.session;\n                error = _yield$this$_callRefr3.error;\n                if (!error) {\n                  _context12.next = 19;\n                  break;\n                }\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n              case 19:\n                if (session) {\n                  _context12.next = 21;\n                  break;\n                }\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: null\n                });\n              case 21:\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: session.user,\n                    session: session\n                  },\n                  error: null\n                });\n              case 24:\n                _context12.prev = 24;\n                _context12.t0 = _context12[\"catch\"](0);\n                if (!isAuthError(_context12.t0)) {\n                  _context12.next = 28;\n                  break;\n                }\n                return _context12.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context12.t0\n                });\n              case 28:\n                throw _context12.t0;\n              case 29:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 24]]);\n      }));\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var error_description, error_code, _error4, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                if (isBrowser()) {\n                  _context13.next = 3;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No browser detected.');\n              case 3:\n                if (this._isImplicitGrantFlow()) {\n                  _context13.next = 5;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n              case 5:\n                error_description = getParameterByName('error_description');\n                if (!error_description) {\n                  _context13.next = 14;\n                  break;\n                }\n                error_code = getParameterByName('error_code');\n                if (error_code) {\n                  _context13.next = 10;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No error_code detected.');\n              case 10:\n                _error4 = getParameterByName('error');\n                if (_error4) {\n                  _context13.next = 13;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No error detected.');\n              case 13:\n                throw new AuthImplicitGrantRedirectError(error_description, {\n                  error: _error4,\n                  code: error_code\n                });\n              case 14:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n                if (access_token) {\n                  _context13.next = 19;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No access_token detected.');\n              case 19:\n                expires_in = getParameterByName('expires_in');\n                if (expires_in) {\n                  _context13.next = 22;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n              case 22:\n                refresh_token = getParameterByName('refresh_token');\n                if (refresh_token) {\n                  _context13.next = 25;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n              case 25:\n                token_type = getParameterByName('token_type');\n                if (token_type) {\n                  _context13.next = 28;\n                  break;\n                }\n                throw new AuthImplicitGrantRedirectError('No token_type detected.');\n              case 28:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context13.next = 32;\n                return this.getUser(access_token);\n              case 32:\n                _yield$this$getUser2 = _context13.sent;\n                data = _yield$this$getUser2.data;\n                error = _yield$this$getUser2.error;\n                if (!error) {\n                  _context13.next = 37;\n                  break;\n                }\n                throw error;\n              case 37:\n                user = data.user;\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                redirectType = getParameterByName('type'); // Remove tokens from URL\n                window.location.hash = '';\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    redirectType: redirectType\n                  },\n                  error: null\n                });\n              case 44:\n                _context13.prev = 44;\n                _context13.t0 = _context13[\"catch\"](0);\n                if (!isAuthError(_context13.t0)) {\n                  _context13.next = 48;\n                  break;\n                }\n                return _context13.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    redirectType: null\n                  },\n                  error: _context13.t0\n                });\n              case 48:\n                throw _context13.t0;\n              case 49:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 44]]);\n      }));\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio4 = _context14.sent;\n                data = _yield$this$getSessio4.data;\n                sessionError = _yield$this$getSessio4.error;\n                if (!sessionError) {\n                  _context14.next = 7;\n                  break;\n                }\n                return _context14.abrupt(\"return\", {\n                  error: sessionError\n                });\n              case 7:\n                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n                if (!accessToken) {\n                  _context14.next = 16;\n                  break;\n                }\n                _context14.next = 11;\n                return this.admin.signOut(accessToken);\n              case 11:\n                _yield$this$admin$sig = _context14.sent;\n                error = _yield$this$admin$sig.error;\n                if (!error) {\n                  _context14.next = 16;\n                  break;\n                }\n                if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                  _context14.next = 16;\n                  break;\n                }\n                return _context14.abrupt(\"return\", {\n                  error: error\n                });\n              case 16:\n                _context14.next = 18;\n                return this._removeSession();\n              case 18:\n                this._notifyAllSubscribers('SIGNED_OUT', null);\n                return _context14.abrupt(\"return\", {\n                  error: null\n                });\n              case 20:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _context15.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                  body: {\n                    email: email,\n                    gotrue_meta_security: {\n                      captcha_token: options.captchaToken\n                    }\n                  },\n                  headers: this.headers,\n                  redirectTo: options.redirectTo\n                });\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n              case 6:\n                _context15.prev = 6;\n                _context15.t0 = _context15[\"catch\"](0);\n                if (!isAuthError(_context15.t0)) {\n                  _context15.next = 10;\n                  break;\n                }\n                return _context15.abrupt(\"return\", {\n                  data: null,\n                  error: _context15.t0\n                });\n              case 10:\n                throw _context15.t0;\n              case 11:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 6]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                _context16.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                  body: {\n                    refresh_token: refreshToken\n                  },\n                  headers: this.headers,\n                  xform: _sessionResponse\n                });\n              case 3:\n                return _context16.abrupt(\"return\", _context16.sent);\n              case 6:\n                _context16.prev = 6;\n                _context16.t0 = _context16[\"catch\"](0);\n                if (!isAuthError(_context16.t0)) {\n                  _context16.next = 10;\n                  break;\n                }\n                return _context16.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context16.t0\n                });\n              case 10:\n                throw _context16.t0;\n              case 11:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[0, 6]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var url = this._getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams\n      });\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n      return {\n        data: {\n          provider: provider,\n          url: url\n        },\n        error: null\n      };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _this2 = this;\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _context17.next = 3;\n                return getItemAsync(this.storage, this.storageKey);\n              case 3:\n                currentSession = _context17.sent;\n                if (this._isValidSession(currentSession)) {\n                  _context17.next = 9;\n                  break;\n                }\n                if (!(currentSession !== null)) {\n                  _context17.next = 8;\n                  break;\n                }\n                _context17.next = 8;\n                return this._removeSession();\n              case 8:\n                return _context17.abrupt(\"return\");\n              case 9:\n                timeNow = Math.round(Date.now() / 1000);\n                if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                  _context17.next = 32;\n                  break;\n                }\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context17.next = 28;\n                  break;\n                }\n                this.networkRetries++;\n                _context17.next = 15;\n                return this._callRefreshToken(currentSession.refresh_token);\n              case 15:\n                _yield$this$_callRefr4 = _context17.sent;\n                error = _yield$this$_callRefr4.error;\n                if (!error) {\n                  _context17.next = 25;\n                  break;\n                }\n                console.log(error.message);\n                if (!(error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)) {\n                  _context17.next = 23;\n                  break;\n                }\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(function () {\n                  return _this2._recoverAndRefresh();\n                }, Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return _context17.abrupt(\"return\");\n              case 23:\n                _context17.next = 25;\n                return this._removeSession();\n              case 25:\n                this.networkRetries = 0;\n                _context17.next = 30;\n                break;\n              case 28:\n                _context17.next = 30;\n                return this._removeSession();\n              case 30:\n                _context17.next = 36;\n                break;\n              case 32:\n                if (!this.persistSession) {\n                  _context17.next = 35;\n                  break;\n                }\n                _context17.next = 35;\n                return this._saveSession(currentSession);\n              case 35:\n                this._notifyAllSubscribers('SIGNED_IN', currentSession);\n              case 36:\n                _context17.next = 42;\n                break;\n              case 38:\n                _context17.prev = 38;\n                _context17.t0 = _context17[\"catch\"](0);\n                console.error(_context17.t0);\n                return _context17.abrupt(\"return\");\n              case 42:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this, [[0, 38]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$_refreshA, data, error, result, _result;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!this.refreshingDeferred) {\n                  _context18.next = 2;\n                  break;\n                }\n                return _context18.abrupt(\"return\", this.refreshingDeferred.promise);\n              case 2:\n                _context18.prev = 2;\n                this.refreshingDeferred = new Deferred();\n                if (refreshToken) {\n                  _context18.next = 6;\n                  break;\n                }\n                throw new AuthSessionMissingError();\n              case 6:\n                _context18.next = 8;\n                return this._refreshAccessToken(refreshToken);\n              case 8:\n                _yield$this$_refreshA = _context18.sent;\n                data = _yield$this$_refreshA.data;\n                error = _yield$this$_refreshA.error;\n                if (!error) {\n                  _context18.next = 13;\n                  break;\n                }\n                throw error;\n              case 13:\n                if (data.session) {\n                  _context18.next = 15;\n                  break;\n                }\n                throw new AuthSessionMissingError();\n              case 15:\n                _context18.next = 17;\n                return this._saveSession(data.session);\n              case 17:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n                result = {\n                  session: data.session,\n                  error: null\n                };\n                this.refreshingDeferred.resolve(result);\n                return _context18.abrupt(\"return\", result);\n              case 23:\n                _context18.prev = 23;\n                _context18.t0 = _context18[\"catch\"](2);\n                if (!isAuthError(_context18.t0)) {\n                  _context18.next = 29;\n                  break;\n                }\n                _result = {\n                  session: null,\n                  error: _context18.t0\n                };\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n                return _context18.abrupt(\"return\", _result);\n              case 29:\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context18.t0);\n                throw _context18.t0;\n              case 31:\n                _context18.prev = 31;\n                this.refreshingDeferred = null;\n                return _context18.finish(31);\n              case 34:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var expiresAt, timeNow, expiresIn, refreshDurationBeforeExpires;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (!this.persistSession) {\n                  this.inMemorySession = session;\n                }\n                expiresAt = session.expires_at;\n                if (expiresAt) {\n                  timeNow = Math.round(Date.now() / 1000);\n                  expiresIn = expiresAt - timeNow;\n                  refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n                  this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n                }\n                if (!(this.persistSession && session.expires_at)) {\n                  _context19.next = 6;\n                  break;\n                }\n                _context19.next = 6;\n                return this._persistSession(session);\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!this.persistSession) {\n                  _context20.next = 5;\n                  break;\n                }\n                _context20.next = 3;\n                return removeItemAsync(this.storage, this.storageKey);\n              case 3:\n                _context20.next = 6;\n                break;\n              case 5:\n                this.inMemorySession = null;\n              case 6:\n                if (this.refreshTokenTimer) {\n                  clearTimeout(this.refreshTokenTimer);\n                }\n              case 7:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds.\n     * @param session The current session.\n     */\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this3 = this;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n          var _yield$this$getSessio5, session, sessionError, _yield$this$_callRefr5, error;\n          return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n            while (1) {\n              switch (_context21.prev = _context21.next) {\n                case 0:\n                  this.networkRetries++;\n                  _context21.next = 3;\n                  return this.getSession();\n                case 3:\n                  _yield$this$getSessio5 = _context21.sent;\n                  session = _yield$this$getSessio5.data.session;\n                  sessionError = _yield$this$getSessio5.error;\n                  if (!(!sessionError && session)) {\n                    _context21.next = 13;\n                    break;\n                  }\n                  _context21.next = 9;\n                  return this._callRefreshToken(session.refresh_token);\n                case 9:\n                  _yield$this$_callRefr5 = _context21.sent;\n                  error = _yield$this$_callRefr5.error;\n                  if (!error) this.networkRetries = 0;\n                  if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n                case 13:\n                case \"end\":\n                  return _context21.stop();\n              }\n            }\n          }, _callee21, this);\n        }));\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      var _this4 = this;\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {\n          return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n            return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n              while (1) {\n                switch (_context22.prev = _context22.next) {\n                  case 0:\n                    if (!(document.visibilityState === 'visible')) {\n                      _context22.next = 5;\n                      break;\n                    }\n                    _context22.next = 3;\n                    return this.initializePromise;\n                  case 3:\n                    _context22.next = 5;\n                    return this._recoverAndRefresh();\n                  case 5:\n                  case \"end\":\n                    return _context22.stop();\n                }\n              }\n            }, _callee22, this);\n          }));\n        });\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      var urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n      }\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n      }\n      if (options === null || options === void 0 ? void 0 : options.queryParams) {\n        var query = new URLSearchParams(options.queryParams);\n        urlParams.push(query.toString());\n      }\n      return \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&'));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var _yield$this$getSessio6, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio6 = _context23.sent;\n                sessionData = _yield$this$getSessio6.data;\n                sessionError = _yield$this$getSessio6.error;\n                if (!sessionError) {\n                  _context23.next = 7;\n                  break;\n                }\n                return _context23.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n              case 7:\n                _context23.next = 9;\n                return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n              case 9:\n                return _context23.abrupt(\"return\", _context23.sent);\n              case 10:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n    }\n    /**\n     * Deletes a registered factor from GoTrue\n     * @param friendlyName Human readable name assigned to a device\n     * @param factorType device which we're validating against. Can only be TOTP for now.\n     * @param issuer domain which the user is enrolling with\n     */\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var _yield$this$getSessio7, sessionData, sessionError, _yield$_request5, data, error;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio7 = _context24.sent;\n                sessionData = _yield$this$getSessio7.data;\n                sessionError = _yield$this$getSessio7.error;\n                if (!sessionError) {\n                  _context24.next = 7;\n                  break;\n                }\n                return _context24.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n              case 7:\n                _context24.next = 9;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                  body: {\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType,\n                    issuer: params.issuer\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n              case 9:\n                _yield$_request5 = _context24.sent;\n                data = _yield$_request5.data;\n                error = _yield$_request5.error;\n                if (!error) {\n                  _context24.next = 14;\n                  break;\n                }\n                return _context24.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n              case 14:\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                  data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n                }\n                return _context24.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n              case 16:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n    }\n    /**\n     * Validates a device as part of the enrollment step.\n     * @param factorID System assigned identifier for authenticator device as returned by enroll\n     * @param code Code Generated by an authenticator device\n     */\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var _yield$this$getSessio8, sessionData, sessionError, _yield$_request6, data, error;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio8 = _context25.sent;\n                sessionData = _yield$this$getSessio8.data;\n                sessionError = _yield$this$getSessio8.error;\n                if (!sessionError) {\n                  _context25.next = 7;\n                  break;\n                }\n                return _context25.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n              case 7:\n                _context25.next = 9;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                  body: {\n                    code: params.code,\n                    challenge_id: params.challengeId\n                  },\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n              case 9:\n                _yield$_request6 = _context25.sent;\n                data = _yield$_request6.data;\n                error = _yield$_request6.error;\n                if (!error) {\n                  _context25.next = 14;\n                  break;\n                }\n                return _context25.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n              case 14:\n                _context25.next = 16;\n                return this._saveSession(Object.assign({\n                  expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                }, data));\n              case 16:\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                return _context25.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n              case 18:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n    }\n    /**\n     * Creates a challenge which a user can verify against\n     * @param factorID System assigned identifier for authenticator device as returned by enroll\n     */\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var _yield$this$getSessio9, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio9 = _context26.sent;\n                sessionData = _yield$this$getSessio9.data;\n                sessionError = _yield$this$getSessio9.error;\n                if (!sessionError) {\n                  _context26.next = 7;\n                  break;\n                }\n                return _context26.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n              case 7:\n                _context26.next = 9;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                  headers: this.headers,\n                  jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n              case 9:\n                return _context26.abrupt(\"return\", _context26.sent);\n              case 10:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n    }\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var _yield$this$_challeng, challengeData, challengeError;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return this._challenge({\n                  factorId: params.factorId\n                });\n              case 2:\n                _yield$this$_challeng = _context27.sent;\n                challengeData = _yield$this$_challeng.data;\n                challengeError = _yield$this$_challeng.error;\n                if (!challengeError) {\n                  _context27.next = 7;\n                  break;\n                }\n                return _context27.abrupt(\"return\", {\n                  data: null,\n                  error: challengeError\n                });\n              case 7:\n                _context27.next = 9;\n                return this._verify({\n                  factorId: params.factorId,\n                  challengeId: challengeData.id,\n                  code: params.code\n                });\n              case 9:\n                return _context27.abrupt(\"return\", _context27.sent);\n              case 10:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\n     * Displays all devices for a given user\n     */\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.getUser();\n              case 2:\n                _yield$this$getUser3 = _context28.sent;\n                user = _yield$this$getUser3.data.user;\n                userError = _yield$this$getUser3.error;\n                if (!userError) {\n                  _context28.next = 7;\n                  break;\n                }\n                return _context28.abrupt(\"return\", {\n                  data: null,\n                  error: userError\n                });\n              case 7:\n                factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n                totp = factors.filter(function (factor) {\n                  return factor.factor_type === 'totp' && factor.status === 'verified';\n                });\n                return _context28.abrupt(\"return\", {\n                  data: {\n                    all: factors,\n                    totp: totp\n                  },\n                  error: null\n                });\n              case 10:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n    }\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _yield$this$getSessio10, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.next = 2;\n                return this.getSession();\n              case 2:\n                _yield$this$getSessio10 = _context29.sent;\n                session = _yield$this$getSessio10.data.session;\n                sessionError = _yield$this$getSessio10.error;\n                if (!sessionError) {\n                  _context29.next = 7;\n                  break;\n                }\n                return _context29.abrupt(\"return\", {\n                  data: null,\n                  error: sessionError\n                });\n              case 7:\n                if (session) {\n                  _context29.next = 9;\n                  break;\n                }\n                return _context29.abrupt(\"return\", {\n                  data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                  },\n                  error: null\n                });\n              case 9:\n                payload = this._decodeJWT(session.access_token);\n                currentLevel = null;\n                if (payload.aal) {\n                  currentLevel = payload.aal;\n                }\n                nextLevel = currentLevel;\n                verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                  return factor.status === 'verified';\n                })) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                  nextLevel = 'aal2';\n                }\n                currentAuthenticationMethods = payload.amr || [];\n                return _context29.abrupt(\"return\", {\n                  data: {\n                    currentLevel: currentLevel,\n                    nextLevel: nextLevel,\n                    currentAuthenticationMethods: currentAuthenticationMethods\n                  },\n                  error: null\n                });\n              case 17:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n    }\n  }]);\n  return GoTrueClient;\n}();\nexport { GoTrueClient as default };","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","NETWORK_FAILURE","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","GoTrueClient","options","Map","settings","inMemorySession","storage","admin","fetch","initialize","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","initializePromise","_initialize","_isImplicitGrantFlow","_getSessionFromUrl","data","error","_removeSession","session","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","credentials","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","res","phone","user","_handleProviderSignIn","provider","scopes","queryParams","create_user","shouldCreateUser","params","access_token","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","jwt","getSession","attributes","sessionData","sessionError","userError","timeNow","expiresAt","payload","exp","refreshedSession","getUser","token_type","expires_in","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","accessToken","signOut","status","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","refreshToken","isValidSession","_getUrlForProvider","href","Infinity","networkRetries","console","log","message","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","RETRY_INTERVAL","refreshingDeferred","promise","_refreshAccessToken","result","resolve","reject","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","value","__awaiter","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","_decodeJWT","aal","verifiedFactors","length","amr"],"sources":["C:\\Users\\zoila\\OneDrive\\Escritorio\\Today-i-learned\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\nimport {\n  DEFAULT_HEADERS,\n  EXPIRY_MARGIN,\n  GOTRUE_URL,\n  NETWORK_FAILURE,\n  STORAGE_KEY,\n} from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignInWithSSO,\n  SignUpWithPasswordCredentials,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries = 0\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n\n    this.initialize()\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n        const { data, error } = await this._getSessionFromUrl()\n\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n        if (redirectType === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n        }\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n    return this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n    })\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async updateUser(attributes: UserAttributes): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (!this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    return { data: { subscription } }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n        body: { refresh_token: refreshToken },\n        headers: this.headers,\n        xform: _sessionResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser()) {\n      window.location.href = url\n    }\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error instanceof AuthRetryableFetchError &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          await this._removeSession()\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n\n    if (this.refreshTokenTimer) {\n      clearTimeout(this.refreshTokenTimer)\n    }\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const {\n        data: { session },\n        error: sessionError,\n      } = await this.getSession()\n      if (!sessionError && session) {\n        const { error } = await this._callRefreshToken(session.refresh_token)\n        if (!error) this.networkRetries = 0\n        if (\n          error instanceof AuthRetryableFetchError &&\n          this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n        )\n          this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n      }\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  private _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', async () => {\n        if (document.visibilityState === 'visible') {\n          await this.initializePromise\n          await this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n  }\n\n  /**\n   * Deletes a registered factor from GoTrue\n   * @param friendlyName Human readable name assigned to a device\n   * @param factorType device which we're validating against. Can only be TOTP for now.\n   * @param issuer domain which the user is enrolling with\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n      body: {\n        friendly_name: params.friendlyName,\n        factor_type: params.factorType,\n        issuer: params.issuer,\n      },\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n\n    if (error) {\n      return { data: null, error }\n    }\n\n    if (data?.totp?.qr_code) {\n      data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n    }\n\n    return { data, error: null }\n  }\n\n  /**\n   * Validates a device as part of the enrollment step.\n   * @param factorID System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/factors/${params.factorId}/verify`,\n      {\n        body: { code: params.code, challenge_id: params.challengeId },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      }\n    )\n    if (error) {\n      return { data: null, error }\n    }\n\n    await this._saveSession({\n      expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n      ...data,\n    })\n    this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n    return { data, error }\n  }\n\n  /**\n   * Creates a challenge which a user can verify against\n   * @param factorID System assigned identifier for authenticator device as returned by enroll\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    const { data: sessionData, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n\n    return await _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n      headers: this.headers,\n      jwt: sessionData?.session?.access_token,\n    })\n  }\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * Displays all devices for a given user\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}